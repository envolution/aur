name: Grouped NVCHECKER Updates
on:
  schedule:
    - cron: '0 */12 * * *'  # Runs every 12 hours
  workflow_dispatch:  # Allows manual triggering

jobs:
  arch-task:
    runs-on: ubuntu-latest
    container:
      image: archlinux:latest
      options: --privileged # Required for system-level changes like useradd, pacman
    env:
        AUR_MAINTAINER_NAME: envolution
        GIT_USERNAME: envolution
        GIT_EMAIL: involution@gmail.com
        ACTIONS_STEP_SUMMARY: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}#step:${{ github.job }}:markdown-summary

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Initialize pacman keyring and update system
        run: |
          set -e 
          echo "::group::Initialize pacman and Update System"
          echo "Initializing pacman keyring..."
          mkdir -p /etc/pacman.d/gnupg
          pacman-key --init
          pacman-key --populate archlinux
          
          echo "Enabling multilib repository..."
          echo -e "\n[multilib]\nInclude = /etc/pacman.d/mirrorlist" >> /etc/pacman.conf
          
          echo "Updating system and installing core dependencies..."
          pacman -Sy --noconfirm --needed archlinux-keyring 
          pacman -Syu --noconfirm 
          
          echo "Installing necessary packages..."
          pacman -S --noconfirm --needed \
            git base-devel pacman-contrib openssh github-cli jq expac \
            ruby-rdoc ruby-pkg-config gnupg \
            python python-pip \
            pyalpm python-awesomeversion python-packaging python-lxml \
            python-gobject python-requests libnotify nvchecker \
            binutils multilib-devel python-aiohttp clang python-jq \
            sudo 
          echo "::endgroup::"

      - name: Setup non-root user for AUR operations
        shell: bash
        run: |
          set -e
          echo "::group::Setup non-root user 'builder'"
          echo "Creating build user 'builder'..."
          useradd -m -s /bin/bash builder 
          echo "builder ALL=(ALL) NOPASSWD: ALL" > /etc/sudoers.d/builder
          chmod 0440 /etc/sudoers.d/builder

          echo "Setting up directories for builder..."
          install -d -o builder -g builder -m 700 /home/builder/.gnupg 
          install -d -o builder -g builder -m 755 /home/builder/.cache
          install -d -o builder -g builder -m 755 /home/builder/.local
          install -d -o builder -g builder -m 755 /home/builder/.local/share
          install -d -o builder -g builder -m 755 /home/builder/.cache/paru
          install -d -o builder -g builder -m 755 /home/builder/.local/share/paru

          echo "Builder user setup complete."
          echo "::endgroup::"

      - name: Install paru (AUR helper)
        run: |
          set -e
          echo "::group::Install paru (AUR helper)"
          echo "Installing paru for 'builder' user..."
          cd /tmp
          sudo -u builder git clone https://aur.archlinux.org/paru-bin.git
          cd paru-bin
          sudo -u builder makepkg -si --noconfirm

          echo "Configuring paru..."
          echo -e "[options]\nBatchInstall\nBottomUp\nRemoveMake\nSudoLoop\nUseAsk" | sudo tee /etc/paru.conf > /dev/null
          
          echo "Paru installation and configuration complete."
          echo "::endgroup::"

      - name: Setup SSH key for AUR
        run: |
          set -e
          echo "::group::Setup SSH key for AUR"
          echo "Setting up SSH key for AUR access..."
          SSH_DIR="/home/builder/.ssh"
          mkdir -p "${SSH_DIR}"
          echo "${{ secrets.AUR_SSH_PRIVATE_KEY }}" > "${SSH_DIR}/aur"
          
          ssh-keyscan aur.archlinux.org >> "${SSH_DIR}/known_hosts"
          
          echo "Host aur.archlinux.org" >> "${SSH_DIR}/config"
          echo "  IdentityFile ${SSH_DIR}/aur" >> "${SSH_DIR}/config"
          echo "  User aur" >> "${SSH_DIR}/config" 
          echo "  StrictHostKeyChecking yes" >> "${SSH_DIR}/config"

          chown -R builder:builder "${SSH_DIR}"
          chmod 700 "${SSH_DIR}"
          chmod 600 "${SSH_DIR}/aur"
          chmod 600 "${SSH_DIR}/config" 
          chmod 644 "${SSH_DIR}/known_hosts"
          
          echo "SSH key setup complete. Permissions:"
          ls -ldn "${SSH_DIR}" "${SSH_DIR}/aur" "${SSH_DIR}/config" "${SSH_DIR}/known_hosts" # Use -n to show numeric UID/GID
          echo "::endgroup::"

      - name: Configure Git for builder user
        run: |
          set -e
          echo "::group::Configure Git for builder user"
          echo "Configuring Git for 'builder' user..."
          sudo -u builder git config --global user.name "${{ env.GIT_USERNAME }}"
          sudo -u builder git config --global user.email "${{ env.GIT_EMAIL }}"
          echo "Git configuration complete."
          echo "::endgroup::"

      - name: Run Arch Package Update and Build Task # Debugging new build section
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          AUR_MAINTAINER_NAME: ${{ env.AUR_MAINTAINER_NAME }}
          SECRET_GHUK_VALUE: ${{ secrets.GHuK }}
        run: |
          set -e
          echo 'hello'

          #    ( CARCH="x86_64"; PKGDEST="/tmp/pkgdest"; SRCDEST="/tmp/srcdest"; SRCPKGDEST="/tmp/srcpkgdest"; source "${pkgbuild_dir_abs}/PKGBUILD"; declare -p depends makedepends checkdepends source 2>/dev/null || true ) || 
          #    { echo "::error title=EXTRACT_FAIL::Sourcing/declaring PKGBUILD vars failed for ${pkgbuild_dir_abs}." >&2; return 1; }
          #}

          #process_single_package_details() { 
          #    echo "::debug::process_single_package_details: pkg='$1', rel_dir='$2'" >&2
          #    local package_name="$1"; local pkgbuild_dir_rel_to_workspace="$2"; local declarations
          #    if ! declarations=$(extract_pkgbuild_details "${GITHUB_WORKSPACE}/${pkgbuild_dir_rel_to_workspace}"); then
          #        echo "::error title=PROCESS_FAIL::extract_pkgbuild_details failed for ${package_name}." >&2
          #        jq -n --arg pkg_name_arg "$package_name" '{($pkg_name_arg): {"error": "failed to extract PKGBUILD details"}}'; return 1 
          #    fi
          #    echo "::debug::Bash declarations for ${package_name} to be eval'd: ${declarations}" >&2
          #    unset depends makedepends checkdepends source; eval "$declarations" 
          #    local dep_j mak_j chk_j src_j 
          #    if declare -p depends &>/dev/null && [ ${#depends[@]} -gt 0 ]; then dep_j=$(printf '%s\n' "${depends[@]}" | jq -R -s -c 'split("\n")[:-1]'); else dep_j="[]"; fi
          #    if declare -p makedepends &>/dev/null && [ ${#makedepends[@]} -gt 0 ]; then mak_j=$(printf '%s\n' "${makedepends[@]}" | jq -R -s -c 'split("\n")[:-1]'); else mak_j="[]"; fi
          #    if declare -p checkdepends &>/dev/null && [ ${#checkdepends[@]} -gt 0 ]; then chk_j=$(printf '%s\n' "${checkdepends[@]}" | jq -R -s -c 'split("\n")[:-1]'); else chk_j="[]"; fi
          #    if declare -p source &>/dev/null && [ ${#source[@]} -gt 0 ]; then src_j=$(printf '%s\n' "${source[@]}" | jq -R -s -c 'split("\n")[:-1]'); else src_j="[]"; fi
          #    echo "::debug::JSON arrays for ${package_name}: depends=${dep_j}, makedepends=${mak_j}, checkdepends=${chk_j}, sources=${src_j}" >&2
          #    jq -n --arg pkg "$package_name" --argjson d "$dep_j" --argjson m "$mak_j" --argjson c "$chk_j" --argjson s "$src_j" \
          #        '{($pkg): {depends: $d, makedepends: $m, checkdepends: $c, sources: $s}}'
          #}

          # --- Function to call buildscript2.py ---
          #execute_build_script_py() {
          #    local package_name_arg="$1" # Renamed to avoid conflict with any global 'package_name'
          #    local build_type_arg="$2"
          #    local pkgbuild_path_rel_arg="$3"
          #    
          #    _start_group "Build Script Execution: ${package_name_arg}"
          #    # Current PWD should be NVCHECKER_RUN_DIR
          #    local package_specific_artifact_dir="${ARTIFACTS_DIR}/${package_name_arg}" 
          #    if ! sudo -u builder mkdir -p "${package_specific_artifact_dir}"; then
          #        _log_error "BUILD_SCRIPT_MKDIR_FAIL" "Failed to create artifact subdir ${package_specific_artifact_dir} for ${package_name_arg}."
          #        _end_group; return 1 # Critical failure for this package build
          #    fi

          #    _log_notice "BUILD_SCRIPT_PY_EXEC" "Starting buildscript2.py for package: ${package_name_arg} (Type: ${build_type_arg}, PKGBUILD Path: ${pkgbuild_path_rel_arg})"
          #    
          #    local build_script_executable_path="./buildscript2.py" # It's in NVCHECKER_RUN_DIR (current dir)
          #    local captured_build_output_json # Variable to store stdout
          #    local build_script_actual_exit_code=0
          #    
          #    # Temporarily redirect stderr to a file to capture it without 'set -x' pollution, then display if error
          #    local build_stderr_log; build_stderr_log=$(mktemp)

          #    # Use a subshell for the command substitution to isolate its potential failure from `set -e` on the `if` line itself
          #    # if `sudo ... python3 ...` exits non-zero, command substitution yields empty string, and $? is set.
          #    if ! captured_build_output_json=$(sudo -E -u builder \
          #        python3 "${build_script_executable_path}" \
          #        --github-repo "${{ github.repository }}" \
          #        --github-token "${GH_TOKEN}" \
          #        --github-workspace "${GITHUB_WORKSPACE}" \
          #        --package-name "${package_name_arg}" \
          #        --depends-json "${PACKAGE_DETAILS_JSON_PATH}" \
          #        --pkgbuild-path "${pkgbuild_path_rel_arg}" \
          #        --commit-message "CI: Auto update ${package_name_arg}" \
          #        --build-mode "${build_type_arg}" \
          #        --artifacts-dir "${package_specific_artifact_dir}" \
          #        --debug 2> "${build_stderr_log}" ) ; then
          #        build_script_actual_exit_code=$? # Capture exit code of the sudo command
          #        _log_error "BUILD_SCRIPT_PY_FAIL" "buildscript2.py for '${package_name_arg}' FAILED with exit code ${build_script_actual_exit_code}."
          #    else
          #        _log_debug "buildscript2.py for '${package_name_arg}' apparently succeeded (exit code 0). STDOUT (JSON): ${captured_build_output_json}"
          #    fi
          #    
          #    # Log stderr from buildscript2.py regardless of exit code, if not empty
          #    if [ -s "${build_stderr_log}" ]; then
          #        _log_warning "BUILD_SCRIPT_PY_STDERR" "Stderr from buildscript2.py for ${package_name_arg}:"
          #        cat "${build_stderr_log}" | while IFS= read -r line; do _log_warning "PY_STDERR" "  $line"; done
          #    fi
          #    rm "${build_stderr_log}"

          #    # Parse JSON output from buildscript2.py for summary
          #    local bs_version bs_success bs_changes_detected bs_error_msg # 'local' is fine in function
          #    bs_version=$(echo "${captured_build_output_json}" | jq -r '.version // "N/A"')
          #    bs_success=$(echo "${captured_build_output_json}" | jq -r '.success') 
          #    bs_changes_detected=$(echo "${captured_build_output_json}" | jq -r '.changes_detected') 
          #    bs_error_msg=$(echo "${captured_build_output_json}" | jq -r '.error_message // ""')

          #    if [[ -z "$bs_success" || "$bs_success" == "null" ]]; then
          #        # This can happen if captured_build_output_json is empty (e.g. script failed before printing JSON)
          #        _log_error "BUILD_SCRIPT_JSON_ERR" "Failed to parse JSON from buildscript2.py for ${package_name_arg} or output invalid. Assuming failure."
          #        bs_success="false"; bs_error_msg="${bs_error_msg:-buildscript2.py produced invalid/no JSON. Script exit code was ${build_script_actual_exit_code}.}"
          #    fi

          #    local status_md="❌ Failure"; if [ "$bs_success" = "true" ]; then status_md="✅ Success"; fi
          #    if [ "$bs_success" = "false" ] && [ -n "$bs_error_msg" ] && [ "$bs_error_msg" != "null" ]; then
          #        status_md="${status_md}: <small>$(echo "$bs_error_msg" | sed 's/|/\\|/g; s/\n/<br>/g')</small>"
          #    fi
          #    local changes_md="➖ No"; if [ "$bs_changes_detected" = "true" ]; then changes_md="✔️ Yes"; fi
          #    local aur_link_md="[AUR](https://aur.archlinux.org/packages/${package_name_arg})"
          #    local log_link_md="See 'build-artifacts-${{ github.run_id }}' artifact (<tt>${package_name_arg}/</tt> subdir)"
          #    if ! compgen -G "${package_specific_artifact_dir}/${package_name_arg}-*.log" > /dev/null; then log_link_md="N/A"; fi
          #    
          #    echo "| **${package_name_arg}** | ${bs_version} | ${status_md} | ${changes_md} | ${aur_link_md} | ${log_link_md} |" >> "$GITHUB_STEP_SUMMARY"
          #    _end_group 
          #    [ "$bs_success" = "true" ] # Return true if buildscript2.py reported success
          #}

          # --- Main Execution Flow ---
          
          #echo "## Arch Package Build Summary" > "$GITHUB_STEP_SUMMARY"; echo "| Package | Version | Status | Changes | AUR Link | Build Logs |" >> "$GITHUB_STEP_SUMMARY"; echo "|---|---|---|---|---|---|" >> "$GITHUB_STEP_SUMMARY"

          #if ! setup_environment; then _log_error "MAIN_FAIL" "setup_environment FAILED."; exit 1; fi
          #if ! generate_nvchecker_config; then _log_error "MAIN_FAIL" "generate_nvchecker_config FAILED."; exit 1; fi
          #if ! run_compare_aur_local_versions; then _log_error "MAIN_FAIL" "run_compare_aur_local_versions FAILED."; exit 1; fi
          #if ! run_version_checks; then _log_error "MAIN_FAIL" "run_version_checks FAILED."; exit 1; fi
          #if ! get_package_updates_list; then _log_error "MAIN_FAIL" "get_package_updates_list FAILED."; exit 1; fi

          #_log_notice "MAIN_EXEC" "Pre-build data generation completed. UPDATES count: ${#UPDATES[@]}"
          #if [ ${#UPDATES[@]} -eq 0 ]; then
          #    _log_notice "MAIN_EXEC_NO_UPDATES" "No updates to process. Exiting."
          #    echo "| *No updates found* | - | - | - | - | - |" >> "$GITHUB_STEP_SUMMARY"; exit 0
          #fi

          #_start_group "Process PKGBUILD Details for Updated Packages"
          #_log_notice "JSON_GEN" "Processing PKGBUILD details for ${#UPDATES[@]} updated package(s)..."
          #combined_pkg_details_json="{}" 
          #for package_to_process in "${UPDATES[@]}"; do
          #    _start_group "Processing Details: [${package_to_process}]" 
          #    if [ -z "${package_to_process}" ]; then _log_warning "JSON_GEN_PKG_EMPTY" "Empty pkg name. Skipping."; _end_group; continue; fi
          #    pkg_build_dirs_found=() 
          #    mapfile -t pkg_build_dirs_found < <(find "${GITHUB_WORKSPACE}" -path "*/maintain/build/${package_to_process}" -type d -exec test -f "{}/PKGBUILD" \; -print)
          #    if [ ${#pkg_build_dirs_found[@]} -ne 1 ]; then _log_warning "JSON_GEN_PKG_FIND_ERR" "PKGBUILD dir for '${package_to_process}' error (Found: ${#pkg_build_dirs_found[@]})."; _end_group; continue; fi
          #    package_dir_abs="${pkg_build_dirs_found[0]}"; package_dir_rel_to_workspace="${package_dir_abs#${GITHUB_WORKSPACE}/}" 
          #    single_package_json_fragment=""; process_details_succeeded=true
          #    if ! single_package_json_fragment=$(process_single_package_details "$package_to_process" "$package_dir_rel_to_workspace"); then
          #        _log_warning "JSON_GEN_PKG_PROCESS_FAIL" "process_single_package_details issues for ${package_to_process}."; process_details_succeeded=false; fi
          #    _log_debug "JSON fragment for ${package_to_process}: ${single_package_json_fragment}"
          #    temp_merged_json="" 
          #    if temp_merged_json=$(jq -n --argjson current "$combined_pkg_details_json" --argjson fragment "$single_package_json_fragment" '$current + $fragment'); then
          #       combined_pkg_details_json="$temp_merged_json" 
          #       if ! $process_details_succeeded; then _log_warning "JSON_GEN_PKG_MERGED_ERR" "Merged error JSON for ${package_to_process}."; fi
          #    else _log_error "JSON_GEN_PKG_MERGE_FAIL" "jq merge FAILED for ${package_to_process}."; fi
          #    _end_group 
          #done
          #_log_notice "JSON_GEN_LOOP_END" "Finished loop for PKGBUILD details."
          #echo "${combined_pkg_details_json}" | jq . > "${PACKAGE_DETAILS_JSON_PATH}"
          #if ! chown builder:builder "${PACKAGE_DETAILS_JSON_PATH}"; then _log_warning "JSON_GEN_CHOWN_FAIL" "Failed to chown ${PACKAGE_DETAILS_JSON_PATH}."; fi
          #_log_notice "JSON_GEN_SUMMARY" "${PACKAGE_DETAILS_JSON_PATH} (Size: $(wc -c < "${PACKAGE_DETAILS_JSON_PATH}") bytes) created."
          #_log_debug "Full content of ${PACKAGE_DETAILS_JSON_PATH}:"; cat "${PACKAGE_DETAILS_JSON_PATH}" | while IFS= read -r line; do _log_debug "  $line"; done
          #_end_group 

          # Build packages
          # overall_build_success=true
          # for package_to_build in "${UPDATES[@]}"; do
          #     if [ -z "${package_to_build}" ]; then _log_warning "BUILD_LOOP_SKIP_EMPTY" "Skipping empty package name."; continue; fi
          #     
          #     pkg_build_dirs_found_for_build=()
          #     mapfile -t pkg_build_dirs_found_for_build < <(find "${GITHUB_WORKSPACE}" -path "*/maintain/build/${package_to_build}" -type d -exec test -f "{}/PKGBUILD" \; -print)
          #     if [ ${#pkg_build_dirs_found_for_build[@]} -ne 1 ]; then
          #         _log_error "BUILD_LOOP_FIND_ERR" "PKGBUILD dir error for build: '${package_to_build}' (Found: ${#pkg_build_dirs_found_for_build[@]})."
          #         echo "| **${package_to_build}** | N/A | ❌ Error: PKGBUILD dir not found for build | - | - | N/A |" >> "$GITHUB_STEP_SUMMARY"
          #         overall_build_success=false; continue
          #     fi
          #     package_dir_abs_for_build="${pkg_build_dirs_found_for_build[0]}"
          #     package_dir_rel_to_workspace_for_build="${package_dir_abs_for_build#${GITHUB_WORKSPACE}/}"
 
          #     path_components_for_build=() 
          #     path_components_for_build=($(extract_path_components "${package_dir_rel_to_workspace_for_build}"))
          #     build_mode_from_dir_for_build="nobuild" 
          #     if [ "${#path_components_for_build[@]}" -ge 2 ] && ([[ "${path_components_for_build[1]}" == "build" || "${path_components_for_build[1]}" == "test" ]]); then
          #         build_mode_from_dir_for_build="${path_components_for_build[1]}"
          #     else _log_warning "BUILD_LOOP_MODE_WARN" "Cannot determine build_mode for ${package_to_build} from path ${package_dir_rel_to_workspace_for_build}. Defaulting to 'nobuild'."; fi
          #     _log_debug "Package: ${package_to_build}, Determined build_mode: ${build_mode_from_dir_for_build}"
 
          #     if ! execute_build_script_py "$package_to_build" "$build_mode_from_dir_for_build" "$package_dir_rel_to_workspace_for_build"; then
          #         _log_error "BUILD_LOOP_SCRIPT_FAIL" "Build script execution FAILED for ${package_to_build}."
          #         overall_build_success=false 
          #     fi
          # done

          #if ! $overall_build_success; then
          #    _log_error "MAIN_EXEC_BUILD_FAIL" "One or more packages failed to build. See summary and individual build logs."
          #    exit 1
          #fi
          #_log_notice "MAIN_EXEC" "All tasks completed successfully."

      - name: Upload build logs and artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts-${{ github.run_id }}
          path: ${{ github.workspace }}/artifacts/
          retention-days: 7
