name: Grouped NVCHECKER Updates
on:
  schedule:
    - cron: '0 */12 * * *'  # Runs every 12 hours
  workflow_dispatch:  # Allows manual triggering

jobs:
  arch-task:
    runs-on: ubuntu-latest
    container:
      image: archlinux:latest
      options: --privileged # Required for system-level changes like useradd, pacman
    env:
        AUR_MAINTAINER_NAME: envolution
        GIT_USERNAME: envolution
        GIT_EMAIL: involution@gmail.com
        # For GITHUB_STEP_SUMMARY
        ACTIONS_STEP_SUMMARY: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}#step:${{ github.job }}:markdown-summary

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Initialize pacman keyring and update system
        run: |
          set -e 
          echo "::group::Initialize pacman and Update System"
          echo "Initializing pacman keyring..."
          mkdir -p /etc/pacman.d/gnupg
          pacman-key --init
          pacman-key --populate archlinux
          
          echo "Enabling multilib repository..."
          echo -e "\n[multilib]\nInclude = /etc/pacman.d/mirrorlist" >> /etc/pacman.conf
          
          echo "Updating system and installing core dependencies..."
          pacman -Sy --noconfirm --needed archlinux-keyring 
          pacman -Syu --noconfirm 
          
          echo "Installing necessary packages..."
          pacman -S --noconfirm --needed \
            git base-devel pacman-contrib openssh github-cli jq expac \
            ruby-rdoc ruby-pkg-config gnupg \
            python python-pip \
            pyalpm python-awesomeversion python-packaging python-lxml \
            python-gobject python-requests libnotify nvchecker \
            binutils multilib-devel python-aiohttp clang python-jq \
            sudo 
          echo "::endgroup::"

      - name: Setup non-root user for AUR operations
        shell: bash
        run: |
          set -e
          echo "::group::Setup non-root user 'builder'"
          echo "Creating build user 'builder'..."
          useradd -m -s /bin/bash builder 
          echo "builder ALL=(ALL) NOPASSWD: ALL" > /etc/sudoers.d/builder
          chmod 0440 /etc/sudoers.d/builder

          echo "Setting up directories for builder..."
          install -d -o builder -g builder -m 700 /home/builder/.gnupg 
          install -d -o builder -g builder -m 755 /home/builder/.cache
          install -d -o builder -g builder -m 755 /home/builder/.local
          install -d -o builder -g builder -m 755 /home/builder/.local/share
          install -d -o builder -g builder -m 755 /home/builder/.cache/paru
          install -d -o builder -g builder -m 755 /home/builder/.local/share/paru

          echo "Builder user setup complete."
          echo "::endgroup::"

      - name: Install paru (AUR helper)
        run: |
          set -e
          echo "::group::Install paru (AUR helper)"
          echo "Installing paru for 'builder' user..."
          cd /tmp
          sudo -u builder git clone https://aur.archlinux.org/paru-bin.git
          cd paru-bin
          sudo -u builder makepkg -si --noconfirm

          echo "Configuring paru..."
          echo -e "[options]\nBatchInstall\nBottomUp\nRemoveMake\nSudoLoop\nUseAsk" | sudo tee /etc/paru.conf > /dev/null
          
          echo "Paru installation and configuration complete."
          echo "::endgroup::"

      - name: Setup SSH key for AUR
        run: |
          set -e
          echo "::group::Setup SSH key for AUR"
          echo "Setting up SSH key for AUR access..."
          SSH_DIR="/home/builder/.ssh"
          mkdir -p "${SSH_DIR}"
          echo "${{ secrets.AUR_SSH_PRIVATE_KEY }}" > "${SSH_DIR}/aur"
          
          ssh-keyscan aur.archlinux.org >> "${SSH_DIR}/known_hosts"
          
          echo "Host aur.archlinux.org" >> "${SSH_DIR}/config"
          echo "  IdentityFile ${SSH_DIR}/aur" >> "${SSH_DIR}/config"
          echo "  User aur" >> "${SSH_DIR}/config" 
          echo "  StrictHostKeyChecking yes" >> "${SSH_DIR}/config"

          chown -R builder:builder "${SSH_DIR}"
          chmod 700 "${SSH_DIR}"
          chmod 600 "${SSH_DIR}/aur"
          chmod 600 "${SSH_DIR}/config" 
          chmod 644 "${SSH_DIR}/known_hosts"
          
          echo "SSH key setup complete. Permissions:"
          ls -ldn "${SSH_DIR}" "${SSH_DIR}/aur" "${SSH_DIR}/config" "${SSH_DIR}/known_hosts" # Use -n to show numeric UID/GID
          echo "::endgroup::"

      - name: Configure Git for builder user
        run: |
          set -e
          echo "::group::Configure Git for builder user"
          echo "Configuring Git for 'builder' user..."
          sudo -u builder git config --global user.name "${{ env.GIT_USERNAME }}"
          sudo -u builder git config --global user.email "${{ env.GIT_EMAIL }}"
          echo "Git configuration complete."
          echo "::endgroup::"

          get_package_updates_list() {
              _start_group "Get Package Updates List"; 
              _log_notice "GET_UPDATES" "Determining packages to update using nvcmp -q only..."
              # For now, we are ignoring changes.json from nvcmp's text output
              # as it's not directly usable by the current jq query for 'status: "upgrade"'.
              # The UPDATES array will be primarily populated by nvcmp -q.
              # If your compare_aur_local_versions.py script's changes.json is desired,
              # that would need to be read and processed separately.
              # This simplification focuses on getting nvcmp -q's direct update list.

              if [ ! -f "new.toml" ]; then 
                  _log_error "GET_UPDATES_FAIL" "new.toml not found for nvcmp -q!"; _end_group; return 1; 
              fi

              local updates_from_nvcmp_q=() # 'local' is fine here
              
              mapfile -t updates_from_nvcmp_q < <(sudo -E -u builder nvcmp -c new.toml -q 2>/dev/null || true)
              _log_debug "Found ${#updates_from_nvcmp_q[@]} updates from nvcmp -q."
              printf "  ::debug::updates_from_nvcmp_q: [%s]\n" "$(IFS=,; echo "${updates_from_nvcmp_q[*]}")"
              
              declare -ga UPDATES # Declare UPDATES as a global indexed array
              # Directly use updates_from_nvcmp_q after filtering empty lines if any
              local temp_file_nvcmp_q; temp_file_nvcmp_q=$(mktemp)
              if [ ${#updates_from_nvcmp_q[@]} -gt 0 ]; then
                  printf '%s\n' "${updates_from_nvcmp_q[@]}" > "${temp_file_nvcmp_q}"
              else
                  >"${temp_file_nvcmp_q}" # Create empty temp file
              fi
              mapfile -t UPDATES < <(sort -u "${temp_file_nvcmp_q}" | grep .) 
              rm "${temp_file_nvcmp_q}"


              if [ ${#UPDATES[@]} -eq 0 ]; then 
                  _log_notice "GET_UPDATES" "No packages require updates based on nvcmp -q."
              else 
                  _log_notice "GET_UPDATES" "Found ${#UPDATES[@]} package(s) to update (from nvcmp -q):"
                  printf '  ::notice title=Update Candidate (nvcmp -q)::%s\n' "${UPDATES[@]}"
              fi
              _log_notice "GET_UPDATES" "Package update list generation SUCCEEDED."
              _end_group; return 0
          }
